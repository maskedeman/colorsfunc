"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./pages/home/algo.js":
/*!****************************!*\
  !*** ./pages/home/algo.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Algo; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Algo() {\n    // Your existing functions and logic can go here\n    function getPalette(pixelData, iterations) {\n        if (pixelData.length === 0) {\n            return [];\n        }\n        console.log(\"GetPalette invoked\");\n        if (iterations === 0) {\n            return getAverageColor(pixelData);\n        }\n        const highestChannel = getBroadestChannel(pixelData);\n        const [lowerPart, upperPart] = splitData(pixelData, highestChannel);\n        return [\n            ...getPalette(lowerPart, iterations - 1),\n            ...getPalette(upperPart, iterations - 1)\n        ];\n    }\n    function splitData(pixelData, channelId) {\n        const values = getChannelValues(pixelData, channelId).sort();\n        const mid = Math.ceil(values.length / 2);\n        const median = values[mid];\n        const lower = new Uint8ClampedArray(4 * mid);\n        const upper = new Uint8ClampedArray(pixelData.length - lower.length);\n        let lowerIx = 0, upperIx = 0;\n        for(let pixelIx = 0; pixelIx < pixelData.length; pixelIx += 4){\n            const isLower = pixelData[pixelIx + channelId] < median || upperIx >= upper.length;\n            const target = isLower ? lower : upper;\n            const targetIx = isLower ? lowerIx : upperIx;\n            for(let channelId = 0; channelId < 4; channelId++){\n                target[targetIx + channelId] = pixelData[pixelIx + channelId];\n            }\n            isLower ? lowerIx += 4 : upperIx += 4;\n        }\n        return [\n            lower,\n            upper\n        ];\n    }\n    function getChannelValues(pixelData, channelId) {\n        const values = new Uint8ClampedArray(pixelData.length / 4);\n        for(let vix = 0, ix = channelId; ix < pixelData.length; vix++, ix += 4){\n            values[vix] = pixelData[ix];\n        }\n        return values;\n    }\n    function getBroadestChannel(pixelData) {\n        const min = Array(3).fill(255);\n        const max = Array(3).fill(0);\n        for(let channelId = 0; channelId < 4; channelId++){\n            for(let ix = channelId; ix < pixelData.length; ix += 4){\n                const val = pixelData[ix];\n                if (val < min[channelId]) {\n                    min[channelId] = val;\n                }\n                if (val > max[channelId]) {\n                    max[channelId] = val;\n                }\n            }\n        }\n        const ranges = max.map((upper, i)=>upper - min[i]);\n        return ranges.reduce((maxIx, range, i)=>range > ranges[maxIx] ? i : maxIx, 0);\n    }\n    function getAverageColor(pixelData) {\n        const sums = [\n            0,\n            0,\n            0,\n            0\n        ];\n        for(let i = 0; i < pixelData.length; i += 4){\n            for(let j = 0; j < 4; j++){\n                sums[j] += pixelData[i + j];\n            }\n        }\n        const numberOfPixels = pixelData.length / 4;\n        return sums.map((v)=>Math.round(v / numberOfPixels));\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n        fileName: \"D:\\\\Aman\\\\projects\\\\apiInt\\\\colorsfunc\\\\pages\\\\home\\\\algo.js\",\n        lineNumber: 84,\n        columnNumber: 5\n    }, this);\n}\n_c = Algo;\nvar _c;\n$RefreshReg$(_c, \"Algo\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0YsT0FBT0csTUFBTSxDQUNsQixDQUFDQyxPQUFPQyxPQUFPSCxJQUFPRyxRQUFRTCxNQUFNLENBQUNJLE1BQU0sR0FBR0YsSUFBSUUsT0FDbEQ7SUFFSjtJQUVBLFNBQVNsQyxnQkFBZ0JMLFNBQVM7UUFDaEMsTUFBTXlDLE9BQU87WUFBQztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQ3pCLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJckMsVUFBVUUsTUFBTSxFQUFFbUMsS0FBSyxFQUFHO1lBQzVDLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7Z0JBQzFCRCxJQUFJLENBQUNDLEVBQUUsSUFBSTFDLFNBQVMsQ0FBQ3FDLElBQUlLLEVBQUU7WUFDN0I7UUFDRjtRQUNBLE1BQU1DLGlCQUFpQjNDLFVBQVVFLE1BQU0sR0FBRztRQUMxQyxPQUFPdUMsS0FBS0wsR0FBRyxDQUFDLENBQUNRLElBQU01QixLQUFLNkIsS0FBSyxDQUFDRCxJQUFJRDtJQUN4QztJQUVBLHFCQUNFLDhEQUFDRzs7Ozs7QUFJTDtLQXJGd0JoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9ob21lL2FsZ28uanM/MDE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbGdvKCkge1xyXG4gIC8vIFlvdXIgZXhpc3RpbmcgZnVuY3Rpb25zIGFuZCBsb2dpYyBjYW4gZ28gaGVyZVxyXG4gIGZ1bmN0aW9uIGdldFBhbGV0dGUocGl4ZWxEYXRhLCBpdGVyYXRpb25zKSB7XHJcbiAgICBpZiAocGl4ZWxEYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhcIkdldFBhbGV0dGUgaW52b2tlZFwiKTtcclxuICAgIGlmIChpdGVyYXRpb25zID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBnZXRBdmVyYWdlQ29sb3IocGl4ZWxEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoaWdoZXN0Q2hhbm5lbCA9IGdldEJyb2FkZXN0Q2hhbm5lbChwaXhlbERhdGEpO1xyXG4gICAgY29uc3QgW2xvd2VyUGFydCwgdXBwZXJQYXJ0XSA9IHNwbGl0RGF0YShwaXhlbERhdGEsIGhpZ2hlc3RDaGFubmVsKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIC4uLmdldFBhbGV0dGUobG93ZXJQYXJ0LCBpdGVyYXRpb25zIC0gMSksXHJcbiAgICAgIC4uLmdldFBhbGV0dGUodXBwZXJQYXJ0LCBpdGVyYXRpb25zIC0gMSksXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3BsaXREYXRhKHBpeGVsRGF0YSwgY2hhbm5lbElkKSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBnZXRDaGFubmVsVmFsdWVzKHBpeGVsRGF0YSwgY2hhbm5lbElkKS5zb3J0KCk7XHJcbiAgICBjb25zdCBtaWQgPSBNYXRoLmNlaWwodmFsdWVzLmxlbmd0aCAvIDIpO1xyXG4gICAgY29uc3QgbWVkaWFuID0gdmFsdWVzW21pZF07XHJcbiAgICBjb25zdCBsb3dlciA9IG5ldyBVaW50OENsYW1wZWRBcnJheSg0ICogbWlkKTtcclxuICAgIGNvbnN0IHVwcGVyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVsRGF0YS5sZW5ndGggLSBsb3dlci5sZW5ndGgpO1xyXG4gICAgbGV0IGxvd2VySXggPSAwLFxyXG4gICAgICB1cHBlckl4ID0gMDtcclxuICAgIGZvciAobGV0IHBpeGVsSXggPSAwOyBwaXhlbEl4IDwgcGl4ZWxEYXRhLmxlbmd0aDsgcGl4ZWxJeCArPSA0KSB7XHJcbiAgICAgIGNvbnN0IGlzTG93ZXIgPVxyXG4gICAgICAgIHBpeGVsRGF0YVtwaXhlbEl4ICsgY2hhbm5lbElkXSA8IG1lZGlhbiB8fCB1cHBlckl4ID49IHVwcGVyLmxlbmd0aDtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gaXNMb3dlciA/IGxvd2VyIDogdXBwZXI7XHJcbiAgICAgIGNvbnN0IHRhcmdldEl4ID0gaXNMb3dlciA/IGxvd2VySXggOiB1cHBlckl4O1xyXG4gICAgICBmb3IgKGxldCBjaGFubmVsSWQgPSAwOyBjaGFubmVsSWQgPCA0OyBjaGFubmVsSWQrKykge1xyXG4gICAgICAgIHRhcmdldFt0YXJnZXRJeCArIGNoYW5uZWxJZF0gPSBwaXhlbERhdGFbcGl4ZWxJeCArIGNoYW5uZWxJZF07XHJcbiAgICAgIH1cclxuICAgICAgaXNMb3dlciA/IChsb3dlckl4ICs9IDQpIDogKHVwcGVySXggKz0gNCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2xvd2VyLCB1cHBlcl07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRDaGFubmVsVmFsdWVzKHBpeGVsRGF0YSwgY2hhbm5lbElkKSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkocGl4ZWxEYXRhLmxlbmd0aCAvIDQpO1xyXG4gICAgZm9yIChsZXQgdml4ID0gMCwgaXggPSBjaGFubmVsSWQ7IGl4IDwgcGl4ZWxEYXRhLmxlbmd0aDsgdml4KyssIGl4ICs9IDQpIHtcclxuICAgICAgdmFsdWVzW3ZpeF0gPSBwaXhlbERhdGFbaXhdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEJyb2FkZXN0Q2hhbm5lbChwaXhlbERhdGEpIHtcclxuICAgIGNvbnN0IG1pbiA9IEFycmF5KDMpLmZpbGwoMjU1KTtcclxuICAgIGNvbnN0IG1heCA9IEFycmF5KDMpLmZpbGwoMCk7XHJcbiAgICBmb3IgKGxldCBjaGFubmVsSWQgPSAwOyBjaGFubmVsSWQgPCA0OyBjaGFubmVsSWQrKykge1xyXG4gICAgICBmb3IgKGxldCBpeCA9IGNoYW5uZWxJZDsgaXggPCBwaXhlbERhdGEubGVuZ3RoOyBpeCArPSA0KSB7XHJcbiAgICAgICAgY29uc3QgdmFsID0gcGl4ZWxEYXRhW2l4XTtcclxuICAgICAgICBpZiAodmFsIDwgbWluW2NoYW5uZWxJZF0pIHtcclxuICAgICAgICAgIG1pbltjaGFubmVsSWRdID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsID4gbWF4W2NoYW5uZWxJZF0pIHtcclxuICAgICAgICAgIG1heFtjaGFubmVsSWRdID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmFuZ2VzID0gbWF4Lm1hcCgodXBwZXIsIGkpID0+IHVwcGVyIC0gbWluW2ldKTtcclxuICAgIHJldHVybiByYW5nZXMucmVkdWNlKFxyXG4gICAgICAobWF4SXgsIHJhbmdlLCBpKSA9PiAocmFuZ2UgPiByYW5nZXNbbWF4SXhdID8gaSA6IG1heEl4KSxcclxuICAgICAgMFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEF2ZXJhZ2VDb2xvcihwaXhlbERhdGEpIHtcclxuICAgIGNvbnN0IHN1bXMgPSBbMCwgMCwgMCwgMF07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVsRGF0YS5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgIHN1bXNbal0gKz0gcGl4ZWxEYXRhW2kgKyBqXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgbnVtYmVyT2ZQaXhlbHMgPSBwaXhlbERhdGEubGVuZ3RoIC8gNDtcclxuICAgIHJldHVybiBzdW1zLm1hcCgodikgPT4gTWF0aC5yb3VuZCh2IC8gbnVtYmVyT2ZQaXhlbHMpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2PlxyXG4gICAgICB7LyogWW91ciBSZWFjdCBjb21wb25lbnQgY29udGVudCBnb2VzIGhlcmUgKi99XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkFsZ28iLCJnZXRQYWxldHRlIiwicGl4ZWxEYXRhIiwiaXRlcmF0aW9ucyIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJnZXRBdmVyYWdlQ29sb3IiLCJoaWdoZXN0Q2hhbm5lbCIsImdldEJyb2FkZXN0Q2hhbm5lbCIsImxvd2VyUGFydCIsInVwcGVyUGFydCIsInNwbGl0RGF0YSIsImNoYW5uZWxJZCIsInZhbHVlcyIsImdldENoYW5uZWxWYWx1ZXMiLCJzb3J0IiwibWlkIiwiTWF0aCIsImNlaWwiLCJtZWRpYW4iLCJsb3dlciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwidXBwZXIiLCJsb3dlckl4IiwidXBwZXJJeCIsInBpeGVsSXgiLCJpc0xvd2VyIiwidGFyZ2V0IiwidGFyZ2V0SXgiLCJ2aXgiLCJpeCIsIm1pbiIsIkFycmF5IiwiZmlsbCIsIm1heCIsInZhbCIsInJhbmdlcyIsIm1hcCIsImkiLCJyZWR1Y2UiLCJtYXhJeCIsInJhbmdlIiwic3VtcyIsImoiLCJudW1iZXJPZlBpeGVscyIsInYiLCJyb3VuZCIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/home/algo.js\n"));

/***/ })

});